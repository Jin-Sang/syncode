// php grammar.
// modified from following:
// the mit license (mit).
// copyright (c) 2015-2020, ivan kochurkin (kvanttt@gmail.com), positive technologies.
// copyright (c) 2019-2020, student main for php7, php8 support.

// permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "software"), to deal
// in the software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the software, and to permit persons to whom the software is
// furnished to do so, subject to the following conditions:

// the above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the software.

// the software is provided "as is", without warranty of any kind, express or
// implied, including but not limited to the warranties of merchantability,
// fitness for a particular purpose and noninfringement. in no event shall the
// authors or copyright holders be liable for any claim, damages or other
// liability, whether in an action of contract, tort or otherwise, arising from,
// out of or in connection with the software or the use or other dealings in
// the software.

file_input: php_block
php_block: import_statement* top_statement+

import_statement: import namespace namespace_name_list semi_colon

top_statement : statement
              | use_declaration
              | namespace_declaration
              | function_declaration
              | class_declaration
              | global_constant_declaration
              | enum_declaration

use_declaration: use (function_ | const)? use_declaration_content_list semi_colon
    
use_declaration_content_list: "\\"? use_declaration_content ("," "\\"? use_declaration_content)*
    
use_declaration_content: namespace_name_list
    
namespace_declaration: namespace (namespace_name_list? open_curly_bracket namespace_statement* close_curly_bracket | namespace_name_list semi_colon)
    
namespace_statement: statement
    | use_declaration
    | function_declaration
    | class_declaration
    | global_constant_declaration
    
function_declaration: attributes? function_ "&"? identifier type_parameter_list_in_brackets? "(" formal_parameter_list ")" (":" question_mark? type_hint)? block_statement
    
class_declaration: attributes? private? modifier? partial? (class_entry_type identifier type_parameter_list_in_brackets? (extends qualified_static_type_ref)? (implements interface_list)? 
    | interface identifier type_parameter_list_in_brackets? (extends interface_list)?) open_curly_bracket class_statement* close_curly_bracket
    
class_entry_type: class
    | trait
    
interface_list: qualified_static_type_ref ("," qualified_static_type_ref)*
    
type_parameter_list_in_brackets: "<:" type_parameter_list ":>"
    | "<:" type_parameter_with_defaults_list ":>"
    | "<:" type_parameter_list "," type_parameter_with_defaults_list ":>"
    
type_parameter_list: type_parameter_decl ("," type_parameter_decl)*
    
type_parameter_with_defaults_list: type_parameter_with_default_decl ("," type_parameter_with_default_decl)*
    
type_parameter_decl: attributes? identifier
    
type_parameter_with_default_decl: attributes? identifier eq (qualified_static_type_ref | primitive_type)
    
generic_dynamic_args: "<:" type_ref ("," type_ref)* ":>"
    
attributes: attribute_group+
    
attribute_group: attribute_start (identifier ":")? attribute ("," attribute)* "]"
    
attribute: qualified_namespace_name arguments?
    
inner_statement_list: inner_statement*
    
inner_statement: statement
    | function_declaration
    | class_declaration
    
// statements

statement: identifier ":"
    | block_statement
    | if_statement
    | while_statement
    | do_while_statement
    | for_statement
    | switch_statement
    | break_statement
    | continue_statement
    | return_statement
    | yield_expression semi_colon
    | global_statement
    | static_variable_statement
    | echo_statement
    | expression_statement
    | unset_statement
    | foreach_statement
    | try_catch_finally
    | throw_statement
    | goto_statement
    | declare_statement
    | empty_statement_
    // | inline_html_statement
    
empty_statement_: semi_colon
    
block_statement: open_curly_bracket inner_statement_list close_curly_bracket
    
if_statement: if parentheses statement else_if_statement* else_statement?
    | if parentheses ":" inner_statement_list else_if_colon_statement* else_colon_statement? end_if semi_colon
    
else_if_statement: else_if parentheses statement
    
else_if_colon_statement: else_if parentheses ":" inner_statement_list
    
else_statement: else statement
    
else_colon_statement: else ":" inner_statement_list
    
while_statement: while parentheses (statement | ":" inner_statement_list end_while semi_colon)
    
do_while_statement: do statement while parentheses semi_colon
    
for_statement: for "(" for_init? semi_colon expression_list? semi_colon for_update? ")" (statement
        | ":" inner_statement_list end_for semi_colon)
    
for_init: expression_list
    
for_update: expression_list
    
switch_statement: switch parentheses (open_curly_bracket semi_colon? switch_block* close_curly_bracket
        | ":" semi_colon? switch_block* end_switch semi_colon)
    
switch_block: ((case expression | default) (":" | semi_colon))+ inner_statement_list
    
break_statement: break expression? semi_colon
    
continue_statement: continue expression? semi_colon
    
return_statement: return expression? semi_colon
    
expression_statement: expression semi_colon
    
unset_statement: unset "(" chain_list ")" semi_colon
    
foreach_statement: foreach ("(" expression as array_destructuring ")"
        | "(" chain as "&"? assignable ("=>" "&"? chain)? ")"
        | "(" expression as assignable ("=>" "&"? chain)? ")"
        | "(" chain as list "(" assignment_list ")" ")") (statement | ":" inner_statement_list end_foreach semi_colon)
    
try_catch_finally: try block_statement (catch_clause+ finally_statement? | catch_clause* finally_statement)
    
catch_clause: catch "(" qualified_static_type_ref ("|" qualified_static_type_ref)* var_name? ")" block_statement
    
finally_statement: finally block_statement
    
throw_statement: throw expression semi_colon
    
goto_statement: goto identifier semi_colon
    
declare_statement: declare "(" declare_list ")" (statement | ":" inner_statement_list end_declare semi_colon)
    
// inline_html_statement: inline_html+
    
declare_list: directive ("," directive)*
    
directive: ticks eq (numeric_constant | real)
    | encoding eq single_quote_string
    | strict_types eq numeric_constant
    
formal_parameter_list: formal_parameter? ("," formal_parameter)* ","?
    
formal_parameter: attributes? member_modifier* question_mark? type_hint? "&"? "..."? variable_initializer
    
type_hint: qualified_static_type_ref
    | callable
    | primitive_type
    | type_hint "|" type_hint
    
global_statement: global global_var ("," global_var)* semi_colon
    
global_var: var_name
    | dollar chain
    | dollar open_curly_bracket expression close_curly_bracket
    
echo_statement: echo expression_list semi_colon
    
static_variable_statement: static variable_initializer ("," variable_initializer)* semi_colon
    
class_statement: attributes? (property_modifiers type_hint? variable_initializer ("," variable_initializer)* semi_colon
        | member_modifiers? (    const type_hint? identifier_initializer ("," identifier_initializer)* semi_colon
            | function_ "&"? identifier type_parameter_list_in_brackets? "(" formal_parameter_list ")" ( base_ctor_call | return_type_decl)? method_body))
    | use qualified_namespace_name_list trait_adaptations
    
trait_adaptations: semi_colon
    | open_curly_bracket trait_adaptation_statement* close_curly_bracket
    
trait_adaptation_statement: trait_precedence
    | trait_alias
    
trait_precedence: qualified_namespace_name "::" identifier instead_of qualified_namespace_name_list semi_colon
    
trait_alias: trait_method_reference as (member_modifier | member_modifier? identifier) semi_colon
    
trait_method_reference: (qualified_namespace_name "::")? identifier
    
base_ctor_call: ":" identifier arguments?
    
return_type_decl: ":" question_mark? type_hint
    
method_body: semi_colon
    | block_statement
    
property_modifiers: member_modifiers
    | var
    
member_modifiers: member_modifier+
    
variable_initializer: var_name (eq constant_initializer)?
    
identifier_initializer: identifier eq constant_initializer
    
global_constant_declaration: attributes? const identifier_initializer ("," identifier_initializer)* semi_colon
    
enum_declaration: enum_ identifier (colon (int_type | string_type))? (implements interface_list)? open_curly_bracket enum_item* close_curly_bracket
    
enum_item: case identifier (eq expression)? semi_colon
    | member_modifiers? function_declaration
    | use qualified_namespace_name_list trait_adaptations
    
expression_list: expression ("," expression)*
    
parentheses: "(" (expression | yield_expression) ")"
    
// expressions
// grouped by priorities: http://php.net/manual/en/language.operators.precedence.php
expression: clone expression                                            # clone_expression
    | new_expr                                                     # new_expression
    | string_constant "[" expression "]"                           # indexer_expression
    | "(" cast_operation ")" expression                            # cast_expression
    | ("~" | "@") expression                                      # unary_operator_expression
    | ("!" | "+" | "-") expression                                # unary_operator_expression
    | ("++" | "--") chain                                         # prefix_inc_dec_expression
    | chain ("++" | "--")                                         # postfix_inc_dec_expression
    | print expression                                            # print_expression
    | array_creation                                               # array_creation_expression
    | chain                                                       # chain_expression
    | constant                                                    # scalar_expression
    | string                                                      # scalar_expression
    | label                                                       # scalar_expression
    | back_quote_string                                             # back_quote_string_expression
    | parentheses                                                 # parenthesis_expression
    | yield                                                       # special_word_expression
    | list "(" assignment_list ")" eq expression                   # special_word_expression
    | is_set "(" chain_list ")"                                     # special_word_expression
    | empty "(" chain ")"                                         # special_word_expression
    | eval "(" expression ")"                                     # special_word_expression
    | exit ( "(" ")" | parentheses)?                              # special_word_expression
    | (include | include_once) expression                          # special_word_expression
    | (require | require_once) expression                          # special_word_expression
    | lambda_function_expr                                          # lambda_function_expression
    | match_expr                                                   # match_expression
    | expression "**" expression             # arithmetic_expression
    | expression instance_of type_ref                               # instance_of_expression
    | expression ("*" | divide | "%") expression             # arithmetic_expression
    | expression ("+" | "-" | ".") expression                # arithmetic_expression
    | expression ("<<" | ">>") expression                    # comparison_expression
    | expression (less | "<=" | greater | ">=") expression   # comparison_expression
    | expression ("===" | "!==" | "==" | is_not_eq) expression # comparison_expression
    | expression "&" expression                              # bitwise_expression
    | expression "^" expression                              # bitwise_expression
    | expression "|" expression                              # bitwise_expression
    | expression "&&" expression                             # bitwise_expression
    | expression "||" expression                             # bitwise_expression
    | expression question_mark expression? ":" expression     # conditional_expression
    | expression "??" expression                             # null_coalescing_expression
    | expression "<=>" expression                            # spaceship_expression
    | throw expression                                            # special_word_expression
    | array_destructuring eq expression                            # array_destruct_expression
    | assignable assignment_operator attributes? expression        # assignment_expression
    | assignable eq attributes? "&" (chain | new_expr)             # assignment_expression
    | expression logical_and expression                       # logical_expression
    | expression logical_xor expression                       # logical_expression
    | expression logical_or expression                        # logical_expression
    
assignable: chain
    | array_creation
    
array_creation: (array "(" array_item_list? ")" | "[" array_item_list? "]") ("[" expression "]")?
    
array_destructuring: "[" ","* indexed_destruct_item (","+ indexed_destruct_item)* ","* "]"
    | "[" keyed_destruct_item (","+ keyed_destruct_item)* ","? "]"
    
indexed_destruct_item: "&"? chain
    
keyed_destruct_item: (expression "=>")? "&"? chain
    
lambda_function_expr: static? function_ "&"? "(" formal_parameter_list ")" lambda_function_use_vars? (":" type_hint)? block_statement
    | lambda_fn "(" formal_parameter_list ")" "=>" expression
    
match_expr: match_ "(" expression ")" open_curly_bracket match_item ("," match_item)* ","? close_curly_bracket
    
match_item: expression ("," expression)* "=>" expression
    
new_expr: new type_ref arguments?
    
assignment_operator: eq
    | "+="
    | "-="
    | "*="
    | "**="
    | "/="
    | ".="
    | "%="
    | "&="
    | "|="
    | "^="
    | "<<="
    | ">>="
    | "??="
    
yield_expression: yield (expression ("=>" expression)? | from expression)
    
array_item_list: array_item ("," array_item)* ","?
    
array_item: expression ("=>" expression)?
    | (expression "=>")? "&" chain
    
lambda_function_use_vars: use "(" lambda_function_use_var ("," lambda_function_use_var)* ")"
    
lambda_function_use_var: "&"? var_name
    
qualified_static_type_ref: qualified_namespace_name generic_dynamic_args?
    | static
    
type_ref: (qualified_namespace_name | indirect_type_ref) generic_dynamic_args?
    | primitive_type
    | static
    | anonymous_class
    
anonymous_class: attributes? private? modifier? partial? (class_entry_type type_parameter_list_in_brackets? (extends qualified_static_type_ref)? (implements interface_list)?
        | interface identifier type_parameter_list_in_brackets? (extends interface_list)?) open_curly_bracket class_statement* close_curly_bracket
    
indirect_type_ref: chain_base ("->" keyed_field_name)*
    
qualified_namespace_name: namespace? "\\"? namespace_name_list
    
namespace_name_list: identifier
    | identifier ("\\" identifier)* ("\\" namespace_name_tail)?
    
namespace_name_tail: identifier (as identifier)?
    | open_curly_bracket namespace_name_tail ("," namespace_name_tail)* ","? close_curly_bracket
    
qualified_namespace_name_list: qualified_namespace_name ("," qualified_namespace_name)*
    
arguments: "(" (actual_argument ("," actual_argument)* | yield_expression)? ","? ")"
    
actual_argument: argument_name? "..."? expression
    | "&" chain
    
argument_name: identifier ":"
    
constant_initializer: constant
    | string
    | array "(" (array_item_list ","?)? ")"
    | "[" (array_item_list ","?)? "]"
    | ("+" | "-") constant_initializer
    | (string | constant) ("." (string | constant))*
    
constant: null
    | literal_constant
    | magic_constant
    | class_constant
    | qualified_namespace_name
    
literal_constant: real
    | boolean_constant
    | numeric_constant
    | string_constant
    
numeric_constant: octal
    | decimal
    | hex
    | binary
    
class_constant: (class | parent_) "::" (identifier | constructor | get | set)
    | (qualified_static_type_ref | keyed_variable | string) "::" (identifier
        | keyed_variable) // "foo"::$bar works in php7
    
string_constant: label
    
string: start_here_doc here_doc_text+
    | start_now_doc here_doc_text+
    | single_quote_string
    | double_quote interpolated_string_part* double_quote
    
interpolated_string_part: string_part
    | unicode_escape
    | chain
    
chain_list: chain ("," chain)*
    
chain: chain_origin member_access*
    //| array_creation // [$a,$b]=$c
    
chain_origin: chain_base
    | function_call
    | "(" new_expr ")"
    
member_access: "->" keyed_field_name actual_arguments?
    
function_call: function_call_name actual_arguments
    
function_call_name: qualified_namespace_name
    | class_constant
    | chain_base
    | parentheses
    
actual_arguments: generic_dynamic_args? arguments+ square_curly_expression*
    
chain_base: keyed_variable ("::" keyed_variable)?
    | qualified_static_type_ref "::" keyed_variable
    
keyed_field_name: keyed_simple_field_name
    | keyed_variable
    
keyed_simple_field_name: (identifier | open_curly_bracket expression close_curly_bracket) square_curly_expression*
    
keyed_variable: dollar* (var_name | dollar open_curly_bracket expression close_curly_bracket) square_curly_expression*
    
square_curly_expression: "[" expression? "]"
    | open_curly_bracket expression close_curly_bracket
    
assignment_list: assignment_list_element? ("," assignment_list_element?)*
    
assignment_list_element: chain
    | list "(" assignment_list ")"
    | array_item
    
modifier: abstract
    | final
    
identifier: label
    | abstract
    | array
    | as
    | binary_cast
    | bool_type
    | boolean_constant
    | break
    | callable
    | case
    | catch
    | class
    | clone
    | const
    | continue
    | declare
    | default
    | do
    | double_cast
    | double_type
    | echo
    | else
    | else_if
    | empty
    | end_declare
    | end_for
    | end_foreach
    | end_if
    | end_switch
    | end_while
    | eval
    | exit
    | extends
    | final
    | finally
    | float_cast
    | for
    | foreach
    | function_
    | global
    | goto
    | if
    | implements
    | import
    | include
    | include_once
    | instance_of
    | instead_of
    | int16_cast
    | int64_type
    | int8_cast
    | interface
    | int_type
    | is_set
    | lambda_fn
    | list
    | logical_and
    | logical_or
    | logical_xor
    | namespace
    | new
    | null
    | object_type
    | parent_
    | partial
    | print
    | private
    | protected
    | public
    | readonly
    | require
    | require_once
    | resource
    | return
    | static
    | string_type
    | switch
    | throw
    | trait
    | try
    | typeof
    | uint_cast
    | unicode_cast
    | unset
    | use
    | var
    | while
    | yield
    | from
    | enum_
    | match_
    | ticks
    | encoding
    | strict_types
    | get
    | set
    | call
    | call_static
    | constructor
    | destruct
    | wakeup
    | sleep
    | autoload
    | is_set__
    | unset__
    | to_string__
    | invoke
    | set_state
    | clone__
    | debug_info
    | namespace__
    | class__
    | traic__
    | function__
    | method__
    | line__
    | file__
    | dir__
    
member_modifier: public
    | protected
    | private
    | static
    | abstract
    | final
    | readonly
    
magic_constant: namespace__
    | class__
    | traic__
    | function__
    | method__
    | line__
    | file__
    | dir__
    
magic_method: get
    | set
    | call
    | call_static
    | constructor
    | destruct
    | wakeup
    | sleep
    | autoload
    | is_set__
    | unset__
    | to_string__
    | invoke
    | set_state
    | clone__
    | debug_info
    
primitive_type: bool_type
    | int_type
    | int64_type
    | double_type
    | string_type
    | resource
    | object_type
    | array
    
cast_operation: bool_type
    | int8_cast
    | int16_cast
    | int_type
    | int64_type
    | uint_cast
    | double_cast
    | double_type
    | float_cast
    | string_type
    | binary_cast
    | unicode_cast
    | array
    | object_type
    | resource
    | unset

attribute_start: "#["

abstract        : "abstract"
array           : "array"
as              : "as"
binary_cast      : "binary"
bool_type        : "bool" "ean"?
boolean_constant : "true" | "false"
break           : "break"
callable        : "callable"
case            : "case"
catch           : "catch"
class           : "class"
clone           : "clone"
const           : "const"
continue        : "continue"
declare         : "declare"
default         : "default"
do              : "do"
double_cast      : "real"
double_type      : "double"
echo            : "echo"
else            : "else"
else_if          : "elseif"
empty           : "empty"
enum_           : "enum"

end_declare : "enddeclare"
end_for     : "endfor"
end_foreach : "endforeach"
end_if      : "endif"
end_switch  : "endswitch"
end_while   : "endwhile"

eval        : "eval"
exit        : "die"
extends     : "extends"
final       : "final"
finally     : "finally"
float_cast   : "float"
for         : "for"
foreach     : "foreach"
function_   : "function"
global      : "global"
goto        : "goto"
if          : "if"
implements  : "implements"
import      : "import"
include     : "include"
include_once : "include_once"
instance_of  : "instanceof"
instead_of   : "insteadof"
int8_cast    : "int8"
int16_cast   : "int16"
int64_type   : "int64"
int_type     : "int" "eger"?
interface   : "interface"
is_set       : "isset"
list        : "list"
logical_and  : "and"
logical_or   : "or"
logical_xor  : "xor"
match_      : "match"
namespace   : "namespace"
new         : "new"
null        : "null"
object_type  : "object"
parent_     : "parent"
partial     : "partial"
print       : "print"
private     : "private"
protected   : "protected"
public      : "public"
readonly    : "readonly"
require     : "require"
require_once : "require_once"
resource    : "resource"
return      : "return"
static      : "static"
string_type  : "string"
switch      : "switch"
throw       : "throw"
trait       : "trait"
try         : "try"
typeof      : "clrtypeof"
uint_cast    : "uint" ("8" | "16" | "64")?
unicode_cast : "unicode"
unset       : "unset"
use         : "use"
var         : "var"
while       : "while"
yield       : "yield"
from        : "from"
lambda_fn    : "fn"
ticks       : "ticks"
encoding    : "encoding"
strict_types : "strict_types"

get         : "__get"
set         : "__set"
call        : "__call"
call_static  : "__callstatic"
constructor : "__construct"
destruct    : "__destruct"
wakeup      : "__wakeup"
sleep       : "__sleep"
autoload    : "__autoload"
is_set__     : "__isset"
unset__     : "__unset"
to_string__  : "__tostring"
invoke      : "__invoke"
set_state    : "__set_state"
clone__     : "__clone"
debug_info   : "__debuginfo"
namespace__ : "__namespace__"
class__     : "__class__"
traic__     : "__trait__"
function__  : "__function__"
method__    : "__method__"
line__      : "__line__"
file__      : "__file__"
dir__       : "__dir__"

spaceship        : "<=>"
lgeneric         : "<:"
rgeneric         : ":>"
double_arrow      : "=>"
inc              : "++"
dec              : "--"
is_identical      : "==="
is_noidentical    : "!=="
is_equal          : "=="
is_not_eq          : "<>" | "!="
is_smaller_or_equal : "<="
is_greater_or_equal : ">="
plus_equal        : "+="
minus_equal       : "-="
mul_equal         : "*="
pow              : "**"
pow_equal         : "**="
div_equal         : "/="
concaequal       : ".="
mod_equal         : "%="
shift_left_equal   : "<<="
shift_right_equal  : ">>="
and_equal         : "&="
or_equal          : "|="
xor_equal         : "^="
boolean_or        : "||"
boolean_and       : "&&"

null_coalescing      : "??"
null_coalescing_equal : "??="

shift_left          : "<<"
shift_right         : ">>"
double_colon        : "::"
object_operator     : "->"
namespace_separator : "\\"
ellipsis           : "..."
less               : "<"
greater            : ">"
ampersand          : "&"
pipe               : "|"
bang               : "!"
caret              : "^"
plus               : "+"
minus              : "-"
asterisk           : "*"
percent            : "%"
divide             : "/"
tilde              : "~"
suppress_warnings   : "@"
dollar             : "$"
dot                : "."
question_mark       : "?"
open_round_bracket   : "("
close_round_bracket  : ")"
open_square_bracket  : "["
close_square_bracket : "]"
open_curly_bracket   : "{"
close_curly_bracket  : "}"
comma              : ","
colon              : ":"
semi_colon          : ";"
eq                 : "="
quote              : "\""
back_quote          : "`"

var_name : "$" name_string
label   : /[a-z_][a-z_0-9]*/
octal   : "0" "o"? octal_digit+ ("_" octal_digit+)*
decimal : "0" | non_zero_digit digit* ("_" digit+)*
real    : (l_num "." l_num? | l_num? "." l_num) exponent_part? | l_num+ exponent_part
hex     : "0x" hex_digit+ ("_" hex_digit+)*
binary  : "0b" /[01]+(_[01]+)*/

back_quote_string   : /\`~\`*\`/
single_quote_string : "\"" /(~(\|\\)|\\.)*/ "\""
double_quote       : "\"" 

start_now_doc: "<<<" /[ \t]*/ "\"" name_string "\""
start_here_doc : "<<<" /[ \t]*/ name_string 

// error_php     : .                       
var_name_in_interpolation : "$" name_string  // todo: fix such cases: "$people->john"
dollar_string           : "$"           
curly_dollar: "{"
curly_string                : "{"    
escaped_char                : "\\"
double_quote_in_interpolation : "\""   
unicode_escape              : "\\u{" /[a-z0-9][a-z0-9]+/ "}"
string_part                 : /~[${\\"]+/

here_doc_text: /~[\r\n]*?/ ("\r"? "\n" | "\r")

name_string: /[a-zA-Z_\u0080-\ufffe][a-zA-Z0-9_\u0080-\ufffe]*/

l_num: /[0-9]+(_[0-9]+)*/
exponent_part: "e" /[+-]?[0-9]+(_[0-9]+)*/
non_zero_digit: /[1-9]/
digit: /[0-9]/
octal_digit: /[0-7]/
hex_digit: /[a-f0-9]/
